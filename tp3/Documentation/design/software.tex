%overview
The ``software'' encompasses all programs that run on the scale units, the master unit, and the user interface client-side code. Despite the vast differences between these targets, the software had to be designed for maximum re-use. A number of feasibility studies were completed before the final approach was selected.

\subsubsection{Master Unit Considerations}
%master unit previous approaches
The master unit would run a full Linux operating systems, therefore more high-level languages and libraries could in theory be used.

Since the user interface was a web application, the master unit had to run a simple web-server that could serve the interface (HTML, Javascript, CSS files) as well as answer requests for dynamically generated information gathered from the scale units. As an initial prototype, the Python language with a webserver module \cite{bottle-py} was used. An open-source project \cite{webiopi} was discovered that would allow control of the GPIO pins and could potentially be adapted for this purpose. However, the serial port communication, and handling of single bytes for communicating with the radio transmitters were found to be insufficiently reliable and scalable.

Instead, it was decided to program the entire system in C, as this would allow for some portions of the code to be re-used on the scale units. This decision was affected by the fact that not much time was left to complete the project, and the web-server and client-side UI were deemed as optional features that could eventually be added in on top of this.

\subsection{Layered Approach}
A layered approach to the software architecture was taken. The system is modelled in three main layers, roughly following the OSI network systems model \cite{osi-model}. Each layer would define a well-known interface, and only the layer above would need to access this. Each layer can have several implementations to account for the fact that the embedded scale unit system would be very different from the Linux system on the master unit.

\begin{itemize}
	\item \bf{Transport Layer:} The lowest layer maps primitive read and write methods to the underlying serial devices and provides buffering for incoming data.
	\item \bf{Packet Layer:} This implements a packet protocol and provides methods for parsing incoming data, as well as packaging outgoing data.
	\item \bf{Application Layer:} The highest layer implements the individual application functionality and defines responses to incoming packets, as well as interacting with other system components, such as the user interface or the analogue-to-digital converter.
\end{itemize}

\subsection{Packet Protocol}
The ZigBee protocol defines a wrapper packet protocol that is used for sending command and data frames across the serial link in the API mode \cite[page 35]{zigbee-datasheet}. This is then translated into another packet format used for over-the-air transmission.

ZigBee nodes can operate in two seperate modes. Firstly, transparent mode is the most basic communication, where only very basic pacektization is provided. However, this is very simple to get running for a basic point-to-point network. Unfortunately, once multiple nodes attempt to transmit at once, the packets become interleaved, rendering this mode not very useful for the envisioned network architecture. Still, it proved useful for initial debugging and manually sending data by connecting the device directly to a serial terminal.

Originally, a simple packet system was devised to run on top of the transparent mode. This was later found to be too unreliable and inefficient due to the aforementioned interleaving of data. Since this design was very similar to the ZigBee API protocol, few changes were required to send the payload data wrapped in packages conforming to this.

The payload consists of an \em{Op-Code} to signify the current operation (ping, pong, measure request, measure response), a \em{device identifier} that is set at compile-time, and the actual data in the case of a measure response. This data is encoded as, in this case four, hexadecimal ASCII characters rather than directly representing it as bytes. This decision was made to avoid having to escape control characters such as \tt{7E} which defines the beginning of a packet in the ZigBee API. In the original design a length byte for the data was included, but this was abandoned since the wrapping API packet already contains a length field.

\subsection{User Interface}
The user interface to the system has been defined during the requirements gathering process to be a very simple web application that should support taking readings of the current system state by intitiating measurements, as well as providing simple calibration of the scales. Therefore a mock-up was drawn up, and based on this a static HTML/CSS prototype was generated (See figure \ref{fig-ui-screenshot}. This could then be made interactive by attaching javascript actions to the buttons.

The client side application (the aforementioned javascript, running in a web-browser) would make asynchronous requests to special URLs on the server that are mapped to methods initiating data transfers between the master and scale units, or returning data previously stored on the server.

\begin{itemize}
	\item \tt{/api/data} returns a JSON \cite{json-spec} object containing the data stored on the server for all sensors.
	\item \tt{/api/calibrate} initiates a measurement on all scale units and sets the values received to be the zero-points for that particular sensor.
	\item \tt{/api/measure} initiates a measurement and stores the results in a server-side structure to be later retreived by a \tt{data} request.
\end{itemize}

It was decided that for the prototype, the master unit program was to be integrated with a previously (for Networked Systems 3 coursework \cite{ns3-webserver}) produced web server implementation, which should require minimal adjustments to support the added API functionality.
